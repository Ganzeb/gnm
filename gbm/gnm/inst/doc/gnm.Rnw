%\VignetteIndexEntry{Overview of gnm} 

\documentclass[a4paper]{article}

\usepackage{Sweave}
\usepackage{alltt}
\usepackage{amsmath}
\usepackage{natbib}

\setlength{\oddsidemargin}{0.5in}
\setlength{\evensidemargin}{0.5in}
\setlength{\textwidth}{5.5in}

\title{Generalized nonlinear models in R: an overview of the \texttt{gnm}
  package} 

\author{Heather Turner and David Firth}

\begin{document}
\maketitle

\tableofcontents

\section{Introduction}

<<"Load gnm">>=
library(gnm)
@ 
\section{Generalized Linear Models}

\section{Nonlinear Terms}

The \texttt{gnm} package provides a flexible framework for the specification and
estimation of generalized models with nonlinear terms. Multiplicative
interaction terms can be estimated using the in-built capability of the
\texttt{gnm} function and are specified in the model formula using the symbolic
function \texttt{Mult}. Other nonlinear terms can be estimated using plug-in
functions for \texttt{gnm} and are specified using \texttt{Nonlin}.

There are two plug-in functions currently available in
the \texttt{gnm} package: \texttt{MultHomog} for fitting multiplicative
interaction terms with homogeneous effects and \texttt{Dref} for fitting
diagonal reference terms. Users may also define custom plug-in functions to fit
other types of nonlinear terms.

\subsection{Multiplicative Interaction Terms using \texttt{Mult}}

Multiplicative interaction terms can be included in the formula argument to
\texttt{gnm} by using the symbolic wrapper function \texttt{Mult}. Factors in
the interaction are passed as unspecified arguments to \texttt{Mult} and are expressed
by symbolic linear formulae. An intercept is automatically added to each
factor unless otherwise specified. For example, to fit the row-column association model
\[\log \mu_{rc} = \alpha_r + \beta_c + \gamma_r\delta_c,\]
also known as the Goodman RC model \citep{Good79}, the \texttt{formula} argument
of \texttt{gnm} would be 
\begin{alltt}
    mu \(\sim\) R + C + Mult(-1 + R, -1 + C)
\end{alltt}
where R and C are row and column factors respectively.

\texttt{Mult} has one specified argument \texttt{multiplicity}, which is
\texttt{1} by default. This argument determines the number of multiplicative
components that are fitted. For example,
\begin{alltt}
    mu \(\sim\) R + C + Mult(-1 + R, -1 + C, multiplicity = 2)
\end{alltt}
would give the RC(2) model \citep{Good79}
\[\log \mu_{rc} = \alpha_r + \beta_c + \gamma_r\delta_c + \theta_r\phi_c.\]

In some contexts, it may be desirable to constrain one or more of the
multiplicative factors so that the factor is always nonnegative. This may be
achieved by defining the factor as an exponential, as in the following `uniform
difference' model \citep{Xie92, Erik92}
\[\log \mu_{ijt} = \alpha_{it} + \beta_{jt} + e^{\gamma_t}\delta_{ij}.\]
Exponentiated factors can be specified in \texttt{gnm} models using the symbolic
function \texttt{Exp}, for example the uniform difference model above would be
specified by the formula
\begin{alltt}
    mu \(\sim\) R:T + C:T + Mult(Exp(-1 + T), R:C, multiplicity = 2)
\end{alltt}

\subsection{Other Nonlinear Terms using \texttt{Nonlin}}

Nonlinear terms which can not be specified using \texttt{Mult} may be specified
using \texttt{Nonlin}. This symbolic function indicates a term which requires a
plug-in function to estimate the associated parameters. There are two arguments
to \texttt{Nonlin}: a call to the relevant plug-in function and if necessary, a
data.frame containing any variables that are required by specified arguments of
the plug-in function, which do not appear in any unspecified arguments of the
plug-in function or elsewhere in the model formula. 

For example, in the formula
\begin{alltt}
    mu ~ x + A + B + Nonlin(PlugInFunction(A, B, arg1 = x, arg2 = C),
                            data = data.frame.of.C)               
\end{alltt}
\texttt{Nonlin} is used to specify a term that requires the plug-in function
PlugInFunction. As the factor $C$ only appears in the specified arguments of the
call to PlugInFunction, a data.frame containing factor C has been passed to the
\texttt{data} argument of \texttt{Nonlin}. Note that this would not be necessary
if $C$ could be found in an environment on the search path (given by
\texttt{search()}).
 
The two plug-in functions included in the \texttt{gnm} package are described
below, followed by a guide to writing custom plug-in functions.

\subsubsection{\texttt{MultHomog}}

The \texttt{MultHomog} function provides the tools required to fit
multiplicative interaction terms in which the level effects are constrained to be
equal across the factors. The arguments of \texttt{MultHomog} are the factors in
the interaction, which are assumed to be objects of class ``factor''. Like a
\texttt{Mult} term, the interaction can include any number of factors, but there
is no multiplicity argument.  

As an example, consider the following association model with homogeneous
row-column effects 
\[\log \mu_{rc} = \alpha_r + \beta_c + \theta_{rc} + \gamma_r\gamma_c.\]
To fit this model, the formula argument to \texttt{gnm} would be
\begin{alltt}
    mu \(\sim\) R + C + Diag(R, C) + Nonlin(MultHomog(R, C))
\end{alltt}

If the factors passed to \texttt{MultHomog} do not have exactly the same levels,
a common set of levels is obtained by taking the union of the levels of each
factor, sorted into increasing order. 

\subsubsection{\texttt{Dref}}
\label{NonlinDref}

\texttt{Dref} is a plug-in function to fit diagonal reference terms involving
two or more factors with a common set of levels. A diagonal reference term
comprises an additive component for each factor. For a given data point, the
component for the $i$'th factor, say $F$, is
\[w_i\gamma_f\]
where $w_i$ is the weight for factor $i$, $\gamma_f$ is the ``diagonal effect''
for level $f$ and $f$ is the level of $F$ for the given data point.

The weights are constrained to be nonnegative and to sum to one so that a
``diagonal effect'', say $\gamma_l$, is the value of the diagonal reference term
for data points with level $l$ across the factors. \texttt{Dref} constrains
the weights by defining them as
\[w_i = \frac{e^{\delta_i}}{\sum_r e^{\delta_r}}\]
and estimating the $\delta_i$.

Factors in the interaction are passed to unspecified arguments of
\texttt{Dref}. For example, the following diagonal reference model for
a contingency table classified by the row factor $R$ and the column factor $C$ 
\[\mu_{rc} =\frac{e^{\delta_1}}{e^{\delta_1} + e^{\delta_2}}\gamma_r +
\frac{e^{\delta_2}}{e^{\delta_1} + e^{\delta_2}}\gamma_c,\]
would be specified by the formula
\begin{alltt}
    mu \(\sim\) -1 + Nonlin(Dref(R, C))
\end{alltt}

\texttt{Dref} has one specified argument \texttt{formula}, which is a symbolic
description of the dependence of $\delta_i$ on any covariates. For example, the formula
\begin{alltt}
    mu \(\sim\) -1 + x + Nonlin(Dref(R, C, formula = ~ 1 + x))
\end{alltt}
specifies the following diagonal reference model
\[\mu_{rc} = \beta_Xx + \frac{e^{\xi_1 + \beta_1x}}{e^{\xi_1 + \beta_1x} + e^{\xi_2 + \beta_2x}}\gamma_r +
\frac{e^{\xi_2 + \beta_2x}}{e^{\xi_1 + \beta_x} + e^{\xi_2 + \beta_2x}}\gamma_c,\]
The default value of \texttt{formula} is $\sim \mbox{\texttt{1}}$, so that
constant weights are estimated. The coefficients returned by \texttt{gnm} are
those that are directly estimated, i.e. the $\delta_i$ or the $\xi_i$ and $\beta_i$,
rather than the implied weights $w_i$.

\subsubsection{Custom Plug-in Functions}

Custom plug-in functions may be written to enable \texttt{gnm} to fit nonlinear
terms that can not be specified by \texttt{Mult} or the plug-in functions provided
by the \texttt{gnm} package. 

There are no constraints on the arguments that a plug-in function may
have. However it should not be assumed that model variables exist in an
environment on the search path, since \texttt{gnm} does not assume this. Rather
the function \texttt{getModelFrame} should be used to get the model.frame used
by \texttt{gnm}, which will have all the model variables and also attributes
useful for model.matrix etc.

For example, the first few lines of the \texttt{MultHomog} function are
\begin{alltt}
    MultHomog <- function(...)\{
      labelList <- as.character((match.call(expand.dots = FALSE))[[2]])
      gnmData <- getModelFrame()
      designList <- lapply(gnmData[, labelList], class.ind)
    ...
\end{alltt}
The names of the factors in the interaction are assigned to \texttt{labelList},
and the model.frame used by \texttt{gnm} is assigned to \texttt{gnmData}. The
factors can then be accessed by name from \texttt{gnmData}, as in the call to
\texttt{lapply}. 

The plug-in function should return a list with the following components
\begin{description}
\item[start]
  (optional) either a vector of default starting values
  for the parameters or a function which takes
  the number of parameters and returns a vector of default
  starting values. See Section \ref{start} for details of how these values will
  be used if provided and the generic default values that will be used otherwise.
\item[labels]
  a character vector of labels for the
  parameters (to which \texttt{gnm} will prefix the call to the
  plug-in function).
\item[predictor]
  a function which takes a vector of parameter estimates
  and returns either a vector of fitted values or a matrix whose columns are
  additive components of the fitted values.
\item[localDesignFunction]
  a function which takes the specified
  arguments \texttt{coef} (a vector of parameter estimates) and 
  \texttt{predictor} (the result of the predictor function), and
  returns the local design matrix.
\end{description}

As an example of a \texttt{start} component, \texttt{Dref} simply returns
\begin{alltt}
    rep(0.5, length(labels))
\end{alltt}
where \texttt{labels} is the vector of parameter labels to be returned as the
\texttt{labels} component, for instance
\begin{alltt}
    c("A", "B", "1", "2", "3", "4", "5", "6", "7")
\end{alltt}

The \texttt{MultHomog} function provides a simple example of a
\texttt{predictor} component:
\begin{alltt}
    predictor <- function(coef) \{
        do.call("pprod", lapply(designList, "%*%", coef))
    \}
\end{alltt}
which computes the product of the vectors found by multiplying the design matrix
for each factor in the interaction (held in \texttt{designList}) by the
homogeneous coefficients (in \texttt{coef}). This function takes advantage of
\textit{lexical scoping}: \texttt{designList} is an object defined in
\texttt{MultHomog}, which \texttt{predictor} is able to find because
\texttt{predictor} is also defined in \texttt{MultHomog} and hence
\texttt{MultHomog} is the enclosing environment of \texttt{predictor}. 

The \texttt{localDesignFunction} created by \texttt{MultHomog} is slightly more
complicated: 
\begin{alltt}
    localDesignFunction <- function(coef, ...) \{
        productList <- designList
        for (i in seq(designList))
            productList[[i]] <- designList[[i]] * 
                drop(do.call("pprod", lapply(designList[-i], "%*%", coef)))
        do.call("psum", productList)
    \}
\end{alltt}
This function only requires the argument \texttt{coef}, but since the
local design function returned by a plug-in function must also take the
argument \texttt{predictor}, further arguments are allowed by the use of the
special argument ``...''.

\section{Controlling the Fitting Procedure}

\texttt{gnm} has a number of arguments which affect the way a model will be
fitted. Basic control parameters and starting values can be set by
\texttt{control} and \texttt{start} respectively. Parameters can be constrained
to zero by specifying a \texttt{constrain} argument. Finally parameters of a
stratification factor can be handled more efficiently by specifying the term in
an \texttt{eliminate} argument. These options are described in more detail below.

\subsection{Using \texttt{control} with \texttt{gnmControl}}

The \texttt{control} argument provides a way to specify the tolerance level for
convergence, the number of starting iterations and the maximum number of main
iterations, as well as the option to trace the deviance throughout the fitting
process.  By default, the \texttt{control} argument is a call to
\texttt{gnmControl} using any arguments passed on from
\texttt{gnm}. \texttt{gnmControl} creates a list of the control
parameters, including any at their default values. For example
\begin{alltt}
    gnm(mu \(\sim\) R + C + Mult(-1 + R, -1 + C), tolerance = 1e-6, iterStart = 3)
\end{alltt}
is equivalent to 
\begin{alltt}
    gnm(mu \(\sim\) R + C + Mult(-1 + R, -1 + C),
        control = gnmControl(tolerance = 1e-6, iterStart = 3))
\end{alltt}
which is the same as
\begin{alltt}
    gnm(mu \(\sim\) R + C + Mult(-1 + R, -1 + C),
        control = list(tolerance = 1e-6, iterStart = 3, iterMax = 500, trace = FALSE))
\end{alltt}

\subsection{Using \texttt{start}}
\label{start}

In some contexts, the default starting values may not be appropriate and the
algorithm will fail to converge, or perhaps only converge after a large number
of iterations. Alternative starting values may be passed on to \texttt{gnm} by
specifying a \texttt{start} argument. This should be a numeric vector of length
equal to the number of parameters (or possibly the non-eliminated parameters,
see Section \ref{eliminate}), however missing starting values (\texttt{NA}s) are
allowed. 

If there is no user-specified starting value for a parameter, the
default value is used. This feature is particularly useful when adding terms to
a model, since the estimates from the original model can be used as starting
values, as in the example below
\begin{alltt}
    model1 <- gnm(mu \(\sim\) R + C + Mult(-1 + R, -1 + C))
    model2 <- gnm(mu \(\sim\) R + C + Mult(-1 + R, -1 + C, multiplicity = 2),
                  start = c(coef(model1), rep(NA, 10))
\end{alltt}
\texttt{gnm} can be run with \texttt{method = "coef"} to identify the
parameters of a model prior to estimation, to assist with the specification of
arguments such as \texttt{start}.

The starting procedure used by \texttt{gnm} is as follows
\begin{enumerate}
\item
Generate starting values $\theta_i$ for all parameters $i = 1, \ldots, p$ from
the Uniform(-0.1, 0.1) distribution. Shift these values away from zero as follows
\begin{equation*}
\theta_i = \begin{cases}
    \theta_i - 0.1 &  \text{if } \theta < 1 \\
    \theta_i + 0.1 & \text{otherwise}
\end{cases}
\end{equation*}
\item
Replace generic starting values with any starting values specified by plug-in
functions.
\item
Replace default starting values with any starting values specified by the
\texttt{start} argument of \texttt{gnm}.
\item
Compute the \texttt{glm} estimate of any parameters in linear terms that were
not specified by \texttt{start}, offsetting the contribution to the predictor of
any parameters specified by \texttt{start} or a plug-in function.
\item
Run starting iterations: update any parameters in nonlinear terms
that were not specified by \texttt{start} or a plug-in function one at a time,
updating \textit{all} linear terms after each round of nonlinear updates.
\end{enumerate}
Note that no starting iterations will be run if all parameters are specified by
the \texttt{start} argument of \texttt{gnm}.

\subsection{Using \texttt{constrain}}
\label{constrain}

By default, \texttt{gnm} only imposes identifiability constraints on any linear
terms in the model to be fitted. For these terms, the constraints are determined
in the same way as they would be in \texttt{glm}. Any nonlinear terms will be
over-parameterized unless constraints are imposed by the defining plug-in
function (as in the case of \texttt{Dref} for example). For a model with
nonlinear terms that are over-parameterized, \texttt{gnm} will return a random
parameterisation. 

To illustrate this point, consider the following application of \texttt{gnm},
discussed later in Section \ref{RCmodels}
<<"RC homogeneous model 1">>=
data(occupationalStatus)
set.seed(1)
RChomog1 <- gnm(Freq ~ origin + destination + Diag(origin, destination) + 
               Nonlin(MultHomog(origin, destination)), family = poisson, 
               data = occupationalStatus)
@ 
Running the analysis again from a different seed
<<"RC homogeneous model 2">>=
set.seed(2)
RChomog2 <- eval(RChomog1$call)
@ 
gives a different representation of the same model
<<"Compare coefficients">>=
compareCoef <- cbind(coef(RChomog1), coef(RChomog2))
colnames(compareCoef) <- c("RChomog1", "RChomog2") 
compareCoef
@
Even though the linear terms are constrained, the parameter estimates for
these terms still change, because these terms are aliased with the higher order
multiplicative interaction, which is unconstrained.

Additional constraints may be specified through the \texttt{constrain} argument
of \texttt{gnm}. This argument indicates parameters that are to be constrained 
to zero in the fitting process. Parameters can be indicated by a logical vector,
a vector of indices or, if \texttt{constrain = "pick"} they can be selected
through a Tk dialog. 
 
In the case above, constraining one level of the homogeneous multiplicative
factor is sufficient to make the parameters of the nonlinear term
identifiable, and hence all parameters in the model identifiable. For example,
setting the last level of the homogeneous multiplicative factor to zero 
<<"RC homogeneous constrained model">>=
multCoef <- coef(RChomog1)[grep("Mult", names(coef(RChomog1)))]
set.seed(1)
RChomogConstrained1 <- update(RChomog1, constrain = 31, 
                              start = c(rep(NA, 23), multCoef - multCoef[8]))
set.seed(2)
RChomogConstrained2 <- eval(RChomogConstrained1$call)
identical(coef(RChomogConstrained1), coef(RChomogConstrained2))
@
gives the same results regardless of the random seed set beforehand.

It is not usually so straightforward to constrain all the parameters in a
generalized nonlinear model. However,the simple constraints imposed by
\texttt{constrain} are often sufficient to make particular coefficients of
interest identifiable. The functions \texttt{checkEstimable} or
\texttt{getContrasts}, described in Section \ref{Methods} may be used to check
whether particular contrasts are estimable.

\subsection{Using \texttt{eliminate}}
\label{eliminate}

Sometimes a model will include a ``stratification'' factor which identifies
units for which a unit-specific intercept should be estimated. It is often the
case that such factors have a large number of levels and though they are
required in the model, are not of direct interest in themselves. 

The \texttt{eliminate} argument of \texttt{gnm} can be used to specify a
stratification factor in a model, so that the factor can be handled more
efficiently. The factor should be specified as a formula with a single term, for
example
\begin{alltt}
    gnm(mu ~ -1 + unitID + A + B + Mult(A, B), eliminate = ~ unitID)               
\end{alltt}
The use of \texttt{eliminate} makes the specification of a stratification factor
in the model formula redundant, so the above call is equivalent to 
\begin{alltt}
    gnm(mu ~ A + B + Mult(A, B), eliminate = ~ unitID)               
\end{alltt}
or even
\begin{alltt}
    gnm(mu ~ -1 + A + B + Mult(A, B), eliminate = ~ unitID)               
\end{alltt}

Specifying a stratification factor through \texttt{eliminate} has two
advantages. First, the parameters in the factor are estimated more
efficiently. Second, the estimated parameters are excluded from the returned vector of
coefficients, so that summaries of the model focus on the coefficients of interest.

* bit more on estimation here? *

\section{Methods and Accessor functions}
\label{Methods}

\texttt{gnm} returns an object of class \texttt{c("gnm", "glm", "lm")}. There
are several methods that have been written for objects of class \texttt{"glm"}
or \texttt{"lm"} to facilitate evaluation of the fitted model they
describe. Out of the generic functions in the \texttt{base},
\texttt{stats} and \texttt{graphics} packages for which methods have been written
for \texttt{"glm"} or \texttt{"lm"} objects, Figure \ref{glm.lm} shows those
that can be used to analyse \texttt{"gnm"} objects, whilst Figure \ref{!glm.lm} shows
those that are not implemented for \texttt{"gnm"} objects.

\begin{figure}[!tbph]
    \centering
    \begin{fbox} 
        {
          \begin{tabular*}{7.5cm}{@{\extracolsep{\fill}}lll@{\extracolsep{\fill}}}
              case.names	&	hatvalues	&	print	\\
              coef	&	influence	&	residuals	\\
              cooks.distance	&	labels	&	rstandard	\\
              deviance	&	logLik	&	summary	\\
              extractAIC	&	model.frame	&	variable.names	\\
              family	&	model.matrix	&	vcov	\\
              formula	&	plot	&	weights	\\
          \end{tabular*}
        }
    \end{fbox}
    \caption{Generic functions in the \texttt{base}, \texttt{stats} and
      \texttt{graphics} packages that can be used to analyse \texttt{"gnm"} objects.}
    \label{glm.lm}
\end{figure}

\begin{figure}[!tbph]
    \centering
    \begin{fbox} 
        {
          \begin{tabular*}{4.5cm}{@{\extracolsep{\fill}}ll@{\extracolsep{\fill}}}
              add1	&	drop1	\\
              alias	&	dummy.coef	\\
              anova	&	effects	\\
              confint	&	kappa	\\
              dfbeta	&	predict	\\
              dfbetas	&	proj	\\
          \end{tabular*}
        }
    \end{fbox}
    \caption{Generic functions in the \texttt{base}, \texttt{stats} and
      \texttt{graphics} packages for which methods have been written for
      \texttt{"glm"} or \texttt{"lm"} objects, but which are not implemented for
      \texttt{"gnm"} objects.}
    \label{!glm.lm}
\end{figure}

In addition to the accessor functions shown in Figure \ref{glm.lm}, the
\texttt{gnm} package provides a new generic function \texttt{termPredictors}
that has methods for objects of class \texttt{"gnm"}, \texttt{"glm"} and
\texttt{"lm"}. This function returns the additive contribution of each term to the
predictor. 

Most of the methods listed in Figure \ref{glm.lm} can be used as they would be
for \texttt{"glm"} or \texttt{"lm"} objects, however care must be taken with
\texttt{vcov}, as the variance-covariance matrix will depend on the
parameterisation of the model. In particular, standard errors calculated using
the variance-covariance matrix will only be valid for parameters or contrasts
that are estimable! 

The \texttt{checkEstimable} function can be used to check the estimability of
contrasts. Consider the following model, that is described later in Section
\ref{Unidiff}
<<"Double UNIDIFF model">>=
data(cautres)
doubleUnidiff <- gnm(Freq ~ election:vote + election:class:religion
                     + Mult(Exp(election - 1), religion:vote - 1) +
                     Mult(Exp(election - 1), class:vote - 1), family = poisson, 
                     data = cautres)
@ 
The effects of the first factor of the first multiplicative term are
estimable when the estimate of one of these effects is constrained to zero, say
the effect of the last level. The parameters to be estimated are then the
differences between each effect and the effect of the last level. These
differences can be represented by a contrast matrix as follows 
<<"Contrast matrix">>=
coefs <- names(coef(doubleUnidiff))
contrCoefs <- coefs[grep("Mult1.Factor1", coefs)]
contrMatrix <- matrix(0, length(coefs), length(contrCoefs), 
                      dimnames = list(coefs, contrCoefs))
contrMatrix[contrCoefs, 1:(ncol(contrMatrix) - 1)] <- contr.sum(contrCoefs)
contrMatrix[contrCoefs, 1:(ncol(contrMatrix) - 1)]
@ 
and then their estimability can be checked using \texttt{checkEstimable}
<<"Check estimability 1">>=
checkEstimable(doubleUnidiff, contrMatrix)
@ 
which confirms that the effects for the other three levels are estimable when 
the effect for the last parameter is set to zero.

However, applying the equivalent constraint to the second factor in the
interaction is not sufficient to make the parameters in that factor estimable:
<<"Check estimability 2">>=
coefs <- names(coef(doubleUnidiff))
contrCoefs <- coefs[grep("Mult1.Factor2", coefs)]
contrMatrix <- matrix(0, length(coefs), length(contrCoefs), 
                      dimnames = list(coefs, contrCoefs))
contrMatrix[contrCoefs, 1:(ncol(contrMatrix) - 1)] <- contr.sum(contrCoefs)
checkEstimable(doubleUnidiff, contrMatrix)
@ 

To investigate simple ``sum to zero'' contrasts such as those above, it
is easiest to use the \texttt{getContrasts} function, which checks the
estimability of the contrasts and returns the parameter estimates with their
standard errors. Returning to the example of the first factor in the first
multiplicative interaction, the differences between each effect and the effect
of the last level can be obtained as follows 
<<"Get contrasts 1">>=
coefs.of.interest <- grep("Mult1.Factor1", names(coef(doubleUnidiff)))
getContrasts(doubleUnidiff, coefs.of.interest)
@ %def 
Attempting to obtain the equivalent contrasts for the second factor produces the
following result
<<"Get contrasts 2">>=
coefs.of.interest <- grep("Mult1.Factor2", names(coef(doubleUnidiff)))
getContrasts(doubleUnidiff, coefs.of.interest)
@ %def
\section{Examples}
\label{Examples}

This section provides examples of the wide range of models that may be fitted
using the \texttt{gnm} package. Sections \ref{RCmodels}, \ref{Dref} and 
\ref{Unidiff} consider various models for contingency tables; Section
\ref{GAMMI} considers AMMI and GAMMI models which are typically used in
agricultural applications, and Section \ref{Stereotype} considers the stereotype
model, which is used to model an ordinal response.

\subsection{Row-column Association Models}
\label{RCmodels}

There are several models that have been proposed for modelling the relationship
between the cell means of a contingency table and the cross-classifying
factors. The following examples consider the row-column association models
proposed by \citet{Good79}. The examples shown use data from two-way contingency
tables, but the \texttt{gnm} package can also be used to fit the equivalent
models for higher order tables.

\subsubsection{RC(1) model}

The RC(1) model is a row and column association model with the interaction
between row and column factors represented by one component of the multiplicative
interaction. If the rows are index by $r$ and the columns by $c$, then the
log-multiplicative form of the RC(1) model for the cell means $\mu_{rc}$ is
given by 
\[\log \mu_{rc} = \alpha_r + \beta_c + \gamma_r\delta_c. \]

We shall fit this model to the \texttt{mentalHealth} data set taken from
\citet{Agre02}, which is a two-way contingency table classified by the child's
mental impairment (MHS) and the parents' socioeconomic status (SES). Although
both of these factors are ordered, we do not wish to use polynomial contrasts in
the model, so we begin by setting the contrasts attribute of these factors to
``treatment'' 
<<"Set contrasts attribute">>=
set.seed(1)
data(mentalHealth)
mentalHealth$MHS <- C(mentalHealth$MHS, treatment)
mentalHealth$SES <- C(mentalHealth$SES, treatment)
@
The \texttt{gnm} model is then specified as follows, using the poisson family
with a log link function
<<"RC1 model">>=
RC1model <- gnm(count ~ SES + MHS +
                Mult(-1 + SES, -1 + MHS),
                family = poisson, data = mentalHealth)
RC1model
@ %def 
The row scores (parameters 10 to 15) and the column scores (parameters 16 to 19)
of the multiplicative interaction can be normalized as in Agresti's eqn (9.15)
<<"Normalize scores">>=
rowProbs <- with(mentalHealth, tapply(count, SES, sum) / sum(count))
colProbs <- with(mentalHealth, tapply(count, MHS, sum) / sum(count))
rowScores <- coef(RC1model)[10:15]
colScores <- coef(RC1model)[16:19]
rowScores <- rowScores - sum(rowScores * rowProbs)
colScores <- colScores - sum(colScores * colProbs)
beta1 <- sqrt(sum(rowScores^2 * rowProbs))
beta2 <- sqrt(sum(colScores^2 * colProbs))
assoc <- list(beta = beta1 * beta2,
              mu = rowScores / beta1,
              nu = colScores / beta2)
assoc
@ %def

\subsubsection{RC(2) model}

The RC(1) model can be extended to an RC($m$) model with $m$ components of the
multiplicative interaction. For example, the RC(2) model is given by
\[\log \mu_{rc} = \alpha_r + \beta_c + \gamma_r\delta_c + \theta_r\phi_c. \]
Extra components of the multiplicative interaction can be specified by the
\texttt{multiplicity} component of \texttt{Mult}, so the RC(2) model can be
fitted to the \texttt{mentalHealth} data as follows
<<"RC2 model">>=
RC2model <- gnm(count ~ SES + MHS +
                Mult(-1 + SES, -1 + MHS, multiplicity = 2),
                family = poisson, data = mentalHealth)
RC2model
@

\subsubsection{Homogeneous effects}

If the row and column factors have the same levels, or perhaps some levels in
common, then the row-column interaction could be modelled by a multiplicative
interaction with homogeneous effects, that is
\[\log \mu_{rc} = \alpha_r + \beta_c + \gamma_r\gamma_c.\]

For example, the \texttt{occupationalStatus} data set from \citet{Good79} is a
contingency table classified by the occupational status of fathers (origin) and
their sons (destination). \citet{Good79} fits a row-column association model
with homogeneous effects to these data after deleting the cells on the main
diagonal. Equivalently we can account for the diagonal effects by a separate
\texttt{Diag} term: 
@ 
<<"Homogeneous effects">>=
data(occupationalStatus)
RChomog <- gnm(Freq ~ origin + destination + Diag(origin, destination) +
               Nonlin(MultHomog(origin, destination)), family = poisson,
               data = occupationalStatus)
RChomog
@ %def 

To determine whether it would be better to allow for heterogeneous effects on
the association of the fathers' occupational status and the sons' occupational
status, we can compare this model to the RC(1) model for these data:
<<"Heterogeneous effects">>=
data(occupationalStatus)
RCheterog <- gnm(Freq ~ origin + destination + Diag(origin, destination) +
               Mult(origin, destination), family = poisson,
               data = occupationalStatus)
RChomog$dev - RCheterog$dev
RChomog$df.residual - RCheterog$df.residual
@
In this case there is little gain in allowing heterogeneous effects.

\subsection{Diagonal Reference Models}
\label{Dref}

Diagonal reference models, proposed by \citep{Sobe81, Sobe85}, are designed for
contingency tables classified by factors with the same levels. The cell
means are modelled as a function of the diagonal effects: the mean
responses of the diagonal cells, where the levels of the row and column factors
are the same.

We shall use the \texttt{conformity} data set discussed in \citet{Vand02} to
illustrate the use of diagonal reference models. These data relate to the value
parents place on their children conforming to their rules. There are two
response variables: the mother's conformity score and the father's conformity
score. The data are cross-classified by two factors describing the education
level of the mother and the father, and there are six further covariates.

In their baseline model for the mother's conformity score, \citet{Vand02}
include five of the six covariates (leaving out the father's family conflict
score) and a diagonal reference term with constant weights based on the two
education factors. This model may be expressed as
\[\mu_{rc} = \beta_1x_1 + \beta_2x_2 + \beta_3x_3 +\beta_4x_4 +\beta_5x_5 +
\frac{e^{\delta_1}}{e^{\delta_1} + e^{\delta_2}}\gamma_r +
\frac{e^{\delta_2}}{e^{\delta_1} + e^{\delta_2}}\gamma_c,\] 
see Section \ref{NonlinDref} for more detail on the choice of parameterisation.

The baseline model can be fitted as follows
@ 
<<"Baseline model">>=
set.seed(1)
data(conformity)
A <- gnm(MCFM ~ -1 + AGEM + MRMM + FRMF + MWORK + MFCM + 
         Nonlin(Dref(MOPLM, FOPLF)), family = gaussian, data = conformity)
A
@ %def
Due to the constraints imposed on the weights in the diagonal reference term,
the coefficients of model \texttt{A} are the unique solutions. Therefore
these estimates should correspond to those reported in Table 4 of
\citet{Vand02}. The weights in the diagonal reference term can be evaluated as follows:
@ 
<<"Calculate weights">>=
prop.table(exp(coef(A)[6:7]))
@ %def
giving the values reported by \citet{Vand02}. All the other coefficients of
model A are the same as those reported by \citet{Vand02} except the coefficients
of the mother's gender role (MRMM) and the father's gender role
(FRMF). \citet{Vand02} reversed the signs of the coefficients of these factors
since they were coded in the direction of liberal values, unlike the other
covariates. However, simply reversing the signs of these coefficents does not
give the same model, since the estimates of these coefficients are not
independent of the estimates of the diagonal effects. For consistent
interpretation of the covariate coefficients, it is better to recode the gender
role factors as follows
@ 
<<"Baseline model recoded">>=
MRMM2 <- as.numeric(!conformity$MRMM)
FRMF2 <- as.numeric(!conformity$FRMF)
A <- gnm(MCFM ~ -1 + AGEM + MRMM2 + FRMF2 + MWORK + MFCM + 
         Nonlin(Dref(MOPLM, FOPLF)), family = gaussian, data = conformity)
A
@ %def 
The coefficients of the covariates are now as reported by \citet{Vand02}, but
the diagonal effects have been adjusted appropriately.

\citet{Vand02} compare the baseline model for the mother's conformity score to
several other models in which the weights in the diagonal reference term are
dependent on one of the covariates. One particular model they consider
incorporates an interaction of the weights with the mother's conflict score as
follows  
\[\mu_{rc} = \beta_1x_1 + \beta_2x_2 + \beta_3x_3 +\beta_4x_4 +\beta_5x_5 +
\frac{e^{\xi_1 + \beta_1x}}{e^{\xi_1 + \beta_1x} + 
e^{\xi_2 + \beta_2x}}\gamma_r + \frac{e^{\xi_2 + \beta_2x}}{e^{\xi_1 + \beta_1x}
+ e^{\xi_2 + \beta_2x}}\gamma_c.\] 

This model can be fitted as below, using the original coding for the gender 
role factors for ease of comparison to the results reported by \citet{Vand02},
@ 
<<"Interaction with conflict">>=
F <- gnm(MCFM ~ -1 + AGEM + MRMM + FRMF + MWORK + MFCM + 
         Nonlin(Dref(MOPLM, FOPLF, formula = ~ 1 + MFCM)), family = gaussian, 
         data = conformity)
F
@ %def
In this case there are two sets of weights, one for when the mother's conflict
score is less than average (coded as zero) and one for when the score is greater
than average (coded as one). These can be evaluated as follows
@ 
<<"Interaction model weights">>=
prop.table(exp(coef(F))[c(6,8)])
prop.table(exp(coef(F)[c(7,9)] + coef(F)[c(6,8)]))
@ %def 
giving the same weights as in Table 4 of \citet{Vand02}.

\subsection{Uniform Difference (UNIDIFF) Models}
\label{Unidiff}

Uniform difference models \citep{Xie92, Erik93} use a simplified three-way
interaction to provide an interpretable model of contingency tables classified
by three or more variables. For example, the uniform difference model for a
three-way contingency table, also known as the UNIDIFF model, is given by
\[\mu_{ijk} = \alpha_{ik} + \beta_{jk} + \delta_k\gamma_{ij}.\]
The $\gamma_{ij}$ represent a pattern of association that varies in strength
over the dimension indexed by $k$ and $\delta_k$ represents the strength of that
association at level $k$.

This model can be applied to the \texttt{yaish} data set, which is a
contingency table cross-classified by father's social class (orig), son's social
class (dest) and son's education level (educ). In this case, we can consider the
importance of the association between the social class of father and son across
the education levels:
@ 
<<"UNIDIFF model">>=
set.seed(1)
data(yaish)
unidiff <- gnm(Freq ~ educ:orig + educ:dest +
               Mult(Exp(-1 + educ), orig:dest), family = poisson,
               data = yaish)
coefs.of.interest <- grep("Mult1.Factor1", names(coef(unidiff)))
coef(unidiff)[coefs.of.interest]
@ %def 
The \texttt{coefs.of.interest} are the multipliers of the association between
the social class of father and son. We can contrast each multiplier to that of
the highest education level and obtain the standard errors for these parameters
as follows 
@ 
<<"Unidiff contrasts">>=
getContrasts(unidiff, coefs.of.interest)
@ %def

Four-way contingency tables may be described by the ``double UNIDIFF'' model
\[\mu_{ijkl} = \alpha_{il} + \beta_{jkl} + \delta_l\gamma_{ij} + 
\phi_l\theta_{ik},\]
where the strengths of two, two-way associations with a common variable are
estimated across the levels of the fourth variable.

The \texttt{cautres} data set can be used to illustrate the application of the
double UNIDIFF model. This data set is classified by the variables vote, class,
religion and election. Using a double UNIDIFF model, we can see how the
association between class and vote, and the association between religion and
vote, differ between the most recent election and the other elections:
@ 
<<"double UNIDIFF model">>=
set.seed(1)
data(cautres)
doubleUnidiff <- gnm(Freq ~ election:vote + election:class:religion +
                     Mult(Exp(-1 + election), religion:vote) +
                     Mult(Exp(-1 + election), class:vote),
                     family = poisson, data = cautres)
getContrasts(doubleUnidiff, grep("Mult1.Factor1", names(coef(doubleUnidiff))))
getContrasts(doubleUnidiff, grep("Mult2.Factor1", names(coef(doubleUnidiff))))
@ %def 
\subsection{Generalized Additive Main Effects and Multiplicative Interaction (GAMMI) Models}
\label{GAMMI}

Generalized additive main effects and multiplicative interaction models, or
GAMMI models, were motivated by two-way contingency tables and comprise the row
and column main effects plus one or more components of the multiplicative
interaction. The singular value corresponding to each component is often factored out,
as a measure of the strength of association between the row and column scores,
indicating the importance of the component, or axis.

For cell means $\mu_{rc}$ a GAMMI-K model has the form
\[l\mu_{rc} = \alpha_r + \beta_c + \sum_{k=1}^K
\sigma_k\gamma_{kr}\delta_{kc}. \] 
in which $l$ is a link function, $\alpha_r$ and $\beta_c$ are the row and column
main effects, $\gamma_{kr}$ and $\delta_{kc}$ are the row and column scores for
component $k$ and $\sigma_k$ is the singular value for component $k$. $K$, the
number of components, is less than or equal to the rank of the matrix of
residuals from the main effects.

The row-column association models discussed in Section \ref{RCmodels} are
examples of GAMMI models, with a log link and poisson variance. Here we 
illustrate the use of an AMMI model, which is a GAMMI model with an identity
link and a constant variance. 

We shall use the \texttt{wheat} data set taken from \citet{Varg01}, which gives
wheat yields measured over ten years. First we shall scale these yields and
create a new treatment factor, so that we can reproduce the analysis of
\citet{Varg01} 
@ 
<<"Scale yields">>=
set.seed(1)
data(wheat)
yield.scaled <- wheat$yield * sqrt(3/1000)
treatment <- interaction(wheat$tillage, wheat$summerCrop, wheat$manure,
                         wheat$N, sep = "")
@ %def 
Now we can fit the AMMI-1 model, to the scaled yields using the combined
treatment factor and the year factor from the \texttt{wheat} dataset
@ 
<<"AMMI model">>=
bilinear1 <- gnm(yield.scaled ~ year + treatment + Mult(year, treatment),
                 family = gaussian, data = wheat)
@ %def 
and compare the AMMI-1 model to the main effects model
@ 
<<"AOD">>=
mainEffects <- glm(yield.scaled ~ year + treatment, family = gaussian,
                   data = wheat)
anova(mainEffects, bilinear1)
@ %def 
giving the same results as in Table 1 of \citet{Varg01} (up to error caused by
rounding). 

\subsection{Biplot Models}

Biplots are used to display two-dimensional data transformed into a space
spanned by linearly independent vectors, such as the principal comonents or
singular vectors. The transformed data is plotted on the two axes which show the
most information about the data, for example the first two principal comonents.



To illustrate the use of a GAMMI model, we shall use the \texttt{barley} data
set which describes the incidence of leaf blotch over ten varieties of barley
grown at nine sites. 

\subsection{Stereotype Models}
\label{Stereotype}

\appendix

\section{User-level Functions}

\bibliography{gnm}
\bibliographystyle{plainnat}

\end{document}
