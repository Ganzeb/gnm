%\VignetteIndexEntry{Overview of gnm}

\documentclass[a4paper]{article}

\usepackage{Sweave}
\usepackage{alltt}
\usepackage{amsmath}
\usepackage{natbib}

\setlength{\oddsidemargin}{0.5in}
\setlength{\evensidemargin}{0.5in}
\setlength{\textwidth}{5.5in}

\title{Generalized nonlinear models in R: an overview of the \texttt{gnm}
  package} 

\author{Heather Turner and David Firth}

\begin{document}
\maketitle

\tableofcontents

\section{Introduction}

\section{Generalized Linear Models}

\section{Nonlinear Terms}

The \texttt{gnm} package provides a flexible framework for the specification and
estimation of generalized models with nonlinear terms. Multiplicative
interaction terms can be estimated using the in-built capability of the
\texttt{gnm} function and are specified in the model formula using the symbolic
function \texttt{Mult}. Other nonlinear terms can be estimated using plug-in
functions for \texttt{gnm} and are specified using \texttt{Nonlin}.

There are two plug-in functions currently available in
the \texttt{gnm} package: \texttt{MultHomog} for fitting multiplicative
interaction terms with homogeneous effects and \texttt{Dref} for fitting
diagonal reference terms. Users may also define custom plug-in functions to fit
other types of nonlinear terms.

\subsection{Multiplicative Interaction Terms using \texttt{Mult}}

Multiplicative interaction terms can be included in the formula argument to
\texttt{gnm} by using the symbolic wrapper function \texttt{Mult}. Factors in
the interaction are passed as unspecified arguments to \texttt{Mult} and are expressed
by symbolic linear formulae. An intercept is automatically added to each
factor unless otherwise specified. For example, to fit the row-column association model
\[\log \mu_{rc} = \alpha_r + \beta_c + \gamma_r\delta_c,\]
also known as the Goodman RC model \citep{Good79}, the \texttt{formula} argument
of \texttt{gnm} would be 
\begin{alltt}
    mu \(\sim\) R + C + Mult(-1 + R, -1 + C)
\end{alltt}
where R and C are row and column factors respectively.

\texttt{Mult} has one specified argument \texttt{multiplicity}, which is
\texttt{1} by default. This argument determines the number of multiplicative
components that are fitted. For example,
\begin{alltt}
    mu \(\sim\) R + C + Mult(-1 + R, -1 + C, multiplicity = 2)
\end{alltt}
would give the RC(2) model \citep{Good79}
\[\log \mu_{rc} = \alpha_r + \beta_c + \gamma_r\delta_c + \theta_r\phi_c.\]

In some contexts, it may be desirable to constrain one or more of the
multiplicative factors so that the factor is always nonnegative. This may be
achieved by defining the factor as an exponential, as in the following `uniform
difference' model \citep{Xie92, Erik92}
\[\log \mu_{ijt} = \alpha_{it} + \beta_{jt} + e^{\gamma_t}\delta_{ij}.\]
Exponentiated factors can be specified in \texttt{gnm} models using the symbolic
function \texttt{Exp}, for example the uniform difference model above would be
specified by the formula
\begin{alltt}
    mu \(\sim\) R:T + C:T + Mult(Exp(-1 + T), R:C, multiplicity = 2)
\end{alltt}

\subsection{Other Nonlinear Terms using \texttt{Nonlin}}

Nonlinear terms which can not be specified using \texttt{Mult} may be specified
using \texttt{Nonlin}. This symbolic function indicates a term which requires a
plug-in function to estimate the associated parameters. There are two arguments
to \texttt{Nonlin}: a call to the relevant plug-in function and if necessary, a
data.frame containing any variables that are required by specified arguments of
the plug-in function, which do not appear in any unspecified arguments of the
plug-in function or elsewhere in the model formula. 

For example, in the formula
\begin{alltt}
    mu ~ x + A + B + Nonlin(PlugInFunction(A, B, arg1 = x, arg2 = C)
                                           data = data.frame.of.C)
\end{alltt}
\texttt{Nonlin} is used to specify a term that requires the plug-in function
PlugInFunction. As the factor $C$ only appears in the specified arguments of the
call to PlugInFunction, a data.frame containing factor C has been passed to the
\texttt{data} argument of \texttt{Nonlin}. Note that this would not be necessary
if $C$ could be found in an environment on the search path (given by
\texttt{search()}).
 
The two plug-in functions included in the \texttt{gnm} package are described
below, followed by a guide to writing custom plug-in functions.

\subsubsection{\texttt{MultHomog}}

The \texttt{MultHomog} function provides the tools required to fit
multiplicative interaction terms in which the level effects are constrained to be
equal across the factors. The arguments of \texttt{MultHomog} are the factors in
the interaction, which are assumed to be objects of class ``factor''. Like a
\texttt{Mult} term, the interaction can include any number of factors, but there
is no multiplicity argument.  

As an example, consider the following association model with homogeneous
row-column effects 
\[\log \mu_{rc} = \alpha_r + \beta_c + \theta_{rc} + \gamma_r\gamma_c.\]
To fit this model, the formula argument to \texttt{gnm} would be
\begin{alltt}
    mu \(\sim\) R + C + Diag(R, C) + Nonlin(MultHomog(R, C))
\end{alltt}

If the factors passed to \texttt{MultHomog} do not have exactly the same levels,
a common set of levels is obtained by taking the union of the levels of each
factor, sorted into increasing order. 

\subsubsection{\texttt{Dref}}

\texttt{Dref} is a plug-in function to fit diagonal reference terms involving
two or more factors with a common set of levels. A diagonal reference term
comprises an additive component for each factor. For a given data point, the
component for the $i$'th factor, say $F$, is
\[w_i\gamma_f\]
where $w_i$ is the weight for factor $i$, $\gamma_f$ is the ``diagonal effect''
for level $f$ and $f$ is the level of $F$ for the given data point.

The weights are constrained to be nonnegative and to sum to one so that a
``diagonal effect'', say $\gamma_l$, is the value of the diagonal reference term
for data points with level $l$ across the factors. \texttt{Dref} constrains
the weights by defining them as
\[w_i = \frac{e^{\delta_i}}{\sum_r^n e^{\delta_r}}\]
and estimating the $\delta_i$.

Factors in the interaction are passed to unspecified arguments of
\texttt{Dref}. For example, the following diagonal reference model for
a contingency table classified by the row factor $R$ and the column factor $C$ 
\[\mu_{rc} =\frac{e^{\delta_1}}{e^{\delta_1} + e^{\delta_2}}\gamma_r +
\frac{e^{\delta_2}}{e^{\delta_1} + e^{\delta_2}}\gamma_c,\]
would be specified by the formula
\begin{alltt}
    mu \(\sim\) -1 + Nonlin(Dref(R, C))
\end{alltt}

\texttt{Dref} has one specified argument \texttt{formula}, which is a symbolic
description of the dependence of $\delta_i$ on any covariates. For example, the formula
\begin{alltt}
    mu \(\sim\) -1 + x + Nonlin(Dref(R, C, formula = ~ 1 + x))
\end{alltt}
specifies the following diagonal reference model
\[\mu_{rc} = \beta_Xx + \frac{e^{\xi_1 + \beta_1x}}{e^{\xi_1 + \beta_1x} + e^{\xi_2 + \beta_2x}}\gamma_r +
\frac{e^{\xi_2 + \beta_2x}}{e^{\xi_1 + \beta_x} + e^{\xi_2 + \beta_2x}}\gamma_c,\]
The default value of \texttt{formula} is $\sim \mbox{\texttt{1}}$, so that
constant weights are estimated. The coefficients returned by \texttt{gnm} are
those that are directly estimated, i.e. the $\delta_i$ or the $\xi_i$ and $\beta_i$,
rather than the implied weights $w_i$.

\subsubsection{Custom Plug-in Functions}

Custom plug-in functions may be written to enable \texttt{gnm} to fit nonlinear
terms that can not be specifed by \texttt{Mult} or the plug-in functions provided
by the \texttt{gnm} package. 

There are no constraints on the arguments that a plug-in function may
have. However it should not be assumed that model variables exist in an
environment on the search path, since \texttt{gnm} does not assume this. Rather
the function \texttt{getModelFrame} should be used to get the model.frame used
by \texttt{gnm}, which will have all the model variables and also attributes
useful for model.matrix etc.

For example, the first few lines of the \texttt{MultHomog} function are
\begin{alltt}
    MultHomog <- function(...)\{
      labelList <- as.character((match.call(expand.dots = FALSE))[[2]])
      gnmData <- getModelFrame()
      designList <- lapply(gnmData[, labelList], class.ind)
    ...
\end{alltt}
The names of the factors in the interaction are assigned to \texttt{labelList},
and the model.frame used by \texttt{gnm} is assigned to \texttt{gnmData}. The
factors can then be accessed by name from \texttt{gnmData}, as in the call to
\texttt{lapply}. 

The plug-in function should return a list with the following components
\begin{description}
\item[start]
  (optional) either a vector of default starting values
  for the parameters or a function which takes
  the number of parameters and returns a vector of default
  starting values. See Section \ref{start} for details of how these values will
  be used if provided and the generic default values that will be used otherwise.
\item[labels]
  a character vector of labels for the
  parameters (to which \texttt{gnm} will prefix the call to the
  plug-in function).
\item[predictor]
  a function which takes a vector of parameter estimates
  and returns either a vector of fitted values or a matrix whose columns are
  additive components of the fitted values.
\item[localDesignFunction]
  a function which takes the specified
  arguments \texttt{coef} (a vector of parameter estimates) and 
  \texttt{predictor} (the result of the predictor function), and
  returns the local design matrix.
\end{description}

As an example of a \texttt{start} component, \texttt{Dref} simply returns
\begin{alltt}
    rep(0.5, length(labels))
\end{alltt}
where \texttt{labels} is the vector of parameter labels to be returned as the
\texttt{labels} component, for instance
\begin{alltt}
    c("A", "B", "1", "2", "3", "4", "5", "6", "7")
\end{alltt}

The \texttt{MultHomog} function provides a simple example of a
\texttt{predictor} component:
\begin{alltt}
    predictor <- function(coef) \{
        do.call("pprod", lapply(designList, "%*%", coef))
    \}
\end{alltt}
which computes the product of the vectors found by multiplying the design matrix
for each factor in the interaction (held in \texttt{designList}) by the
homogeneous coefficients (in \texttt{coef}). This function takes advantage of
\textit{lexical scoping}: \texttt{designList} is an object defined in
\texttt{MultHomog}, which \texttt{predictor} is able to find because
\texttt{predictor} is also defined in \texttt{MultHomog} and hence
\texttt{MultHomog} is the enclosing environment of \texttt{predictor}. 

The \texttt{localDesignFunction} created by \texttt{MultHomog} is slightly more
complicated: 
\begin{alltt}
    localDesignFunction <- function(coef, ...) \{
        productList <- designList
        for (i in seq(designList))
            productList[[i]] <- designList[[i]] * 
                drop(do.call("pprod", lapply(designList[-i], "%*%", coef)))
        do.call("psum", productList)
    \}
\end{alltt}
This function only requires the argument \texttt{coef}, but since the
local design function returned by a plug-in function must also take the
argument \texttt{predictor}, further arguments are allowed by the use of the
special argument ``...''.

\section{Controlling the Fitting Procedure}

\texttt{gnm} has a number of arguments which affect the way a model will be
fitted. Basic control parameters and starting values can be set by
\texttt{control} and \texttt{start} respectively. Parameters can be constrained
to zero by specifying a \texttt{constrain} argument. Finally parameters of a
stratification factor can be handled more efficiently by specifying the term in
an \texttt{eliminate} argument. These options are described in more detail below.

\subsection{Using \texttt{control} with \texttt{gnmControl}}

The \texttt{control} argument provides a way to specify the tolerance level for
convergence, the number of starting iterations and the maximum number of main
iterations, as well as the option to trace the deviance throughout the fitting
process.  By default, the \texttt{control} argument is a call to
\texttt{gnmControl} using any arguments passed on from
\texttt{gnm}. \texttt{gnmControl} creates a list of the control
parameters, including any at their default values. For example
\begin{alltt}
    gnm(mu \(\sim\) R + C + Mult(-1 + R, -1 + C), tolerance = 1e-6, iterStart = 3)
\end{alltt}
is equivalent to 
\begin{alltt}
    gnm(mu \(\sim\) R + C + Mult(-1 + R, -1 + C),
        control = gnmControl(tolerance = 1e-6, iterStart = 3))
\end{alltt}
which is the same as
\begin{alltt}
    gnm(mu \(\sim\) R + C + Mult(-1 + R, -1 + C),
        control = list(tolerance = 1e-6, iterStart = 3, iterMax = 500, trace = FALSE))
\end{alltt}

\subsection{Using \texttt{start}}
\label{start}

In some contexts, the default starting values may not be appropriate and the
algorithm will fail to converge, or perhaps only converge after a large number
of iterations. Alternative starting values may be passed on to \texttt{gnm} by
specifying a \texttt{start} argument. This should be a numeric vector of length
equal to the number of parameters (or possibly the non-eliminated parameters,
see Section \ref{eliminate}), however missing starting values (\texttt{NA}s) are
allowed. 

If there is no user-specified starting value for a parameter, the
default value is used. This feature is particularly useful when adding terms to
a model, since the estimates from the original model can be used as starting
values, as in the example below
\begin{alltt}
    model1 <- gnm(mu \(\sim\) R + C + Mult(-1 + R, -1 + C))
    model2 <- gnm(mu \(\sim\) R + C + Mult(-1 + R, -1 + C, multiplicity = 2),
                  start = c(coef(model1), rep(NA, 10))
\end{alltt}
\texttt{gnm} can be run with \texttt{method = "coef"} to identify the
parameters of a model prior to estimation, to assist with the specification of
arguments such as \texttt{start}.

The starting procedure used by \texttt{gnm} is as follows
\begin{enumerate}
\item
Generate starting values $\theta_i$ for all parameters $i = 1, \ldots, p$ from
the Uniform(-0.1, 0.1) distribution. Shift these values away from zero as follows
\begin{equation*}
\theta_i = \begin{cases}
    \theta_i - 0.1 &  \text{if } \theta < 1 \\
    \theta_i + 0.1 & \text{otherwise}
\end{cases}
\end{equation*}
\item
Replace generic starting values with any starting values specified by plug-in
functions.
\item
Replace default starting values with any starting values specified by the
\texttt{start} argument of \texttt{gnm}.
\item
Compute the \texttt{glm} estimate of any parameters in linear terms that were
not specified by \texttt{start}, offsetting the contribution to the predictor of
any parameters specified by \texttt{start} or a plug-in function.
\item
Run starting iterations: update any parameters in nonlinear terms
that were not specified by \texttt{start} or a plug-in function one at a time,
updating \textit{all} linear terms after each round of nonlinear updates.
\end{enumerate}
Note that no starting iterations will be run if all parameters are specified by
the \texttt{start} argument of \texttt{gnm}.

\subsection{Using \texttt{constrain}}



\subsection{Using \texttt{eliminate}}
\label{eliminate}


\section{Methods and Accessor functions}



\section{Examples}

\appendix

\section{User-level Functions}

\bibliography{gnm}
\bibliographystyle{plain}

\end{document}
