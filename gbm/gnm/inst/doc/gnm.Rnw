% -*- mode: noweb; noweb-default-code-mode: R-mode; -*-

\documentclass[a4paper]{article}

\usepackage{Sweave}
\usepackage{alltt}
\usepackage{amsmath}
\usepackage{natbib}

\setlength{\oddsidemargin}{0.5in}
\setlength{\evensidemargin}{0.5in}
\setlength{\textwidth}{5.5in}

\title{Generalized nonlinear models in R: an overview of the \texttt{gnm}
  package} 

\author{Heather Turner and David Firth}

\begin{document}
\maketitle

\tableofcontents

\section{Introduction}

<<"Load gnm">>=
library(gnm)
@ 
\section{Generalized Linear Models}

\section{Nonlinear Terms}

The \texttt{gnm} package provides a flexible framework for the specification and
estimation of generalized models with nonlinear terms. Multiplicative
interaction terms can be estimated using the in-built capability of the
\texttt{gnm} function and are specified in the model formula using the symbolic
function \texttt{Mult}. Other nonlinear terms can be estimated using plug-in
functions for \texttt{gnm} and are specified using \texttt{Nonlin}.

There are two plug-in functions currently available in
the \texttt{gnm} package: \texttt{MultHomog} for fitting multiplicative
interaction terms with homogeneous effects and \texttt{Dref} for fitting
diagonal reference terms. Users may also define custom plug-in functions to fit
other types of nonlinear terms.

\subsection{Multiplicative Interaction Terms using \texttt{Mult}}

Multiplicative interaction terms can be included in the formula argument to
\texttt{gnm} by using the symbolic wrapper function \texttt{Mult}. Factors in
the interaction are passed as unspecified arguments to \texttt{Mult} and are expressed
by symbolic linear formulae. An intercept is automatically added to each
factor unless otherwise specified. For example, to fit the row-column association model
\[\log \mu_{rc} = \alpha_r + \beta_c + \gamma_r\delta_c,\]
also known as the Goodman RC model \citep{Good79}, the \texttt{formula} argument
of \texttt{gnm} would be 
\begin{alltt}
    mu \(\sim\) R + C + Mult(-1 + R, -1 + C)
\end{alltt}
where R and C are row and column factors respectively.

\texttt{Mult} has one specified argument \texttt{multiplicity}, which is
\texttt{1} by default. This argument determines the number of multiplicative
components that are fitted. For example,
\begin{alltt}
    mu \(\sim\) R + C + Mult(-1 + R, -1 + C, multiplicity = 2)
\end{alltt}
would give the RC(2) model \citep{Good79}
\[\log \mu_{rc} = \alpha_r + \beta_c + \gamma_r\delta_c + \theta_r\phi_c.\]

In some contexts, it may be desirable to constrain one or more of the
multiplicative factors so that the factor is always nonnegative. This may be
achieved by defining the factor as an exponential, as in the following `uniform
difference' model \citep{Xie92, Erik92}
\[\log \mu_{ijt} = \alpha_{it} + \beta_{jt} + e^{\gamma_t}\delta_{ij}.\]
Exponentiated factors can be specified in \texttt{gnm} models using the symbolic
function \texttt{Exp}, for example the uniform difference model above would be
specified by the formula
\begin{alltt}
    mu \(\sim\) R:T + C:T + Mult(Exp(-1 + T), R:C, multiplicity = 2)
\end{alltt}

\subsection{Other Nonlinear Terms using \texttt{Nonlin}}

Nonlinear terms which can not be specified using \texttt{Mult} may be specified
using \texttt{Nonlin}. This symbolic function indicates a term which requires a
plug-in function to estimate the associated parameters. There are two arguments
to \texttt{Nonlin}: a call to the relevant plug-in function and if necessary, a
data.frame containing any variables that are required by specified arguments of
the plug-in function, which do not appear in any unspecified arguments of the
plug-in function or elsewhere in the model formula. 

For example, in the formula
\begin{alltt}
    mu ~ x + A + B + Nonlin(PlugInFunction(A, B, arg1 = x, arg2 = C),
                            data = data.frame.of.C)               
\end{alltt}
\texttt{Nonlin} is used to specify a term that requires the plug-in function
PlugInFunction. As the factor $C$ only appears in the specified arguments of the
call to PlugInFunction, a data.frame containing factor C has been passed to the
\texttt{data} argument of \texttt{Nonlin}. Note that this would not be necessary
if $C$ could be found in an environment on the search path (given by
\texttt{search()}).
 
The two plug-in functions included in the \texttt{gnm} package are described
below, followed by a guide to writing custom plug-in functions.

\subsubsection{\texttt{MultHomog}}

The \texttt{MultHomog} function provides the tools required to fit
multiplicative interaction terms in which the level effects are constrained to be
equal across the factors. The arguments of \texttt{MultHomog} are the factors in
the interaction, which are assumed to be objects of class ``factor''. Like a
\texttt{Mult} term, the interaction can include any number of factors, but there
is no multiplicity argument.  

As an example, consider the following association model with homogeneous
row-column effects 
\[\log \mu_{rc} = \alpha_r + \beta_c + \theta_{rc} + \gamma_r\gamma_c.\]
To fit this model, the formula argument to \texttt{gnm} would be
\begin{alltt}
    mu \(\sim\) R + C + Diag(R, C) + Nonlin(MultHomog(R, C))
\end{alltt}

If the factors passed to \texttt{MultHomog} do not have exactly the same levels,
a common set of levels is obtained by taking the union of the levels of each
factor, sorted into increasing order. 

\subsubsection{\texttt{Dref}}

\texttt{Dref} is a plug-in function to fit diagonal reference terms involving
two or more factors with a common set of levels. A diagonal reference term
comprises an additive component for each factor. For a given data point, the
component for the $i$'th factor, say $F$, is
\[w_i\gamma_f\]
where $w_i$ is the weight for factor $i$, $\gamma_f$ is the ``diagonal effect''
for level $f$ and $f$ is the level of $F$ for the given data point.

The weights are constrained to be nonnegative and to sum to one so that a
``diagonal effect'', say $\gamma_l$, is the value of the diagonal reference term
for data points with level $l$ across the factors. \texttt{Dref} constrains
the weights by defining them as
\[w_i = \frac{e^{\delta_i}}{\sum_r^n e^{\delta_r}}\]
and estimating the $\delta_i$.

Factors in the interaction are passed to unspecified arguments of
\texttt{Dref}. For example, the following diagonal reference model for
a contingency table classified by the row factor $R$ and the column factor $C$ 
\[\mu_{rc} =\frac{e^{\delta_1}}{e^{\delta_1} + e^{\delta_2}}\gamma_r +
\frac{e^{\delta_2}}{e^{\delta_1} + e^{\delta_2}}\gamma_c,\]
would be specified by the formula
\begin{alltt}
    mu \(\sim\) -1 + Nonlin(Dref(R, C))
\end{alltt}

\texttt{Dref} has one specified argument \texttt{formula}, which is a symbolic
description of the dependence of $\delta_i$ on any covariates. For example, the formula
\begin{alltt}
    mu \(\sim\) -1 + x + Nonlin(Dref(R, C, formula = ~ 1 + x))
\end{alltt}
specifies the following diagonal reference model
\[\mu_{rc} = \beta_Xx + \frac{e^{\xi_1 + \beta_1x}}{e^{\xi_1 + \beta_1x} + e^{\xi_2 + \beta_2x}}\gamma_r +
\frac{e^{\xi_2 + \beta_2x}}{e^{\xi_1 + \beta_x} + e^{\xi_2 + \beta_2x}}\gamma_c,\]
The default value of \texttt{formula} is $\sim \mbox{\texttt{1}}$, so that
constant weights are estimated. The coefficients returned by \texttt{gnm} are
those that are directly estimated, i.e. the $\delta_i$ or the $\xi_i$ and $\beta_i$,
rather than the implied weights $w_i$.

\subsubsection{Custom Plug-in Functions}

Custom plug-in functions may be written to enable \texttt{gnm} to fit nonlinear
terms that can not be specifed by \texttt{Mult} or the plug-in functions provided
by the \texttt{gnm} package. 

There are no constraints on the arguments that a plug-in function may
have. However it should not be assumed that model variables exist in an
environment on the search path, since \texttt{gnm} does not assume this. Rather
the function \texttt{getModelFrame} should be used to get the model.frame used
by \texttt{gnm}, which will have all the model variables and also attributes
useful for model.matrix etc.

For example, the first few lines of the \texttt{MultHomog} function are
\begin{alltt}
    MultHomog <- function(...)\{
      labelList <- as.character((match.call(expand.dots = FALSE))[[2]])
      gnmData <- getModelFrame()
      designList <- lapply(gnmData[, labelList], class.ind)
    ...
\end{alltt}
The names of the factors in the interaction are assigned to \texttt{labelList},
and the model.frame used by \texttt{gnm} is assigned to \texttt{gnmData}. The
factors can then be accessed by name from \texttt{gnmData}, as in the call to
\texttt{lapply}. 

The plug-in function should return a list with the following components
\begin{description}
\item[start]
  (optional) either a vector of default starting values
  for the parameters or a function which takes
  the number of parameters and returns a vector of default
  starting values. See Section \ref{start} for details of how these values will
  be used if provided and the generic default values that will be used otherwise.
\item[labels]
  a character vector of labels for the
  parameters (to which \texttt{gnm} will prefix the call to the
  plug-in function).
\item[predictor]
  a function which takes a vector of parameter estimates
  and returns either a vector of fitted values or a matrix whose columns are
  additive components of the fitted values.
\item[localDesignFunction]
  a function which takes the specified
  arguments \texttt{coef} (a vector of parameter estimates) and 
  \texttt{predictor} (the result of the predictor function), and
  returns the local design matrix.
\end{description}

As an example of a \texttt{start} component, \texttt{Dref} simply returns
\begin{alltt}
    rep(0.5, length(labels))
\end{alltt}
where \texttt{labels} is the vector of parameter labels to be returned as the
\texttt{labels} component, for instance
\begin{alltt}
    c("A", "B", "1", "2", "3", "4", "5", "6", "7")
\end{alltt}

The \texttt{MultHomog} function provides a simple example of a
\texttt{predictor} component:
\begin{alltt}
    predictor <- function(coef) \{
        do.call("pprod", lapply(designList, "%*%", coef))
    \}
\end{alltt}
which computes the product of the vectors found by multiplying the design matrix
for each factor in the interaction (held in \texttt{designList}) by the
homogeneous coefficients (in \texttt{coef}). This function takes advantage of
\textit{lexical scoping}: \texttt{designList} is an object defined in
\texttt{MultHomog}, which \texttt{predictor} is able to find because
\texttt{predictor} is also defined in \texttt{MultHomog} and hence
\texttt{MultHomog} is the enclosing environment of \texttt{predictor}. 

The \texttt{localDesignFunction} created by \texttt{MultHomog} is slightly more
complicated: 
\begin{alltt}
    localDesignFunction <- function(coef, ...) \{
        productList <- designList
        for (i in seq(designList))
            productList[[i]] <- designList[[i]] * 
                drop(do.call("pprod", lapply(designList[-i], "%*%", coef)))
        do.call("psum", productList)
    \}
\end{alltt}
This function only requires the argument \texttt{coef}, but since the
local design function returned by a plug-in function must also take the
argument \texttt{predictor}, further arguments are allowed by the use of the
special argument ``...''.

\section{Controlling the Fitting Procedure}

\texttt{gnm} has a number of arguments which affect the way a model will be
fitted. Basic control parameters and starting values can be set by
\texttt{control} and \texttt{start} respectively. Parameters can be constrained
to zero by specifying a \texttt{constrain} argument. Finally parameters of a
stratification factor can be handled more efficiently by specifying the term in
an \texttt{eliminate} argument. These options are described in more detail below.

\subsection{Using \texttt{control} with \texttt{gnmControl}}

The \texttt{control} argument provides a way to specify the tolerance level for
convergence, the number of starting iterations and the maximum number of main
iterations, as well as the option to trace the deviance throughout the fitting
process.  By default, the \texttt{control} argument is a call to
\texttt{gnmControl} using any arguments passed on from
\texttt{gnm}. \texttt{gnmControl} creates a list of the control
parameters, including any at their default values. For example
\begin{alltt}
    gnm(mu \(\sim\) R + C + Mult(-1 + R, -1 + C), tolerance = 1e-6, iterStart = 3)
\end{alltt}
is equivalent to 
\begin{alltt}
    gnm(mu \(\sim\) R + C + Mult(-1 + R, -1 + C),
        control = gnmControl(tolerance = 1e-6, iterStart = 3))
\end{alltt}
which is the same as
\begin{alltt}
    gnm(mu \(\sim\) R + C + Mult(-1 + R, -1 + C),
        control = list(tolerance = 1e-6, iterStart = 3, iterMax = 500, trace = FALSE))
\end{alltt}

\subsection{Using \texttt{start}}
\label{start}

In some contexts, the default starting values may not be appropriate and the
algorithm will fail to converge, or perhaps only converge after a large number
of iterations. Alternative starting values may be passed on to \texttt{gnm} by
specifying a \texttt{start} argument. This should be a numeric vector of length
equal to the number of parameters (or possibly the non-eliminated parameters,
see Section \ref{eliminate}), however missing starting values (\texttt{NA}s) are
allowed. 

If there is no user-specified starting value for a parameter, the
default value is used. This feature is particularly useful when adding terms to
a model, since the estimates from the original model can be used as starting
values, as in the example below
\begin{alltt}
    model1 <- gnm(mu \(\sim\) R + C + Mult(-1 + R, -1 + C))
    model2 <- gnm(mu \(\sim\) R + C + Mult(-1 + R, -1 + C, multiplicity = 2),
                  start = c(coef(model1), rep(NA, 10))
\end{alltt}
\texttt{gnm} can be run with \texttt{method = "coef"} to identify the
parameters of a model prior to estimation, to assist with the specification of
arguments such as \texttt{start}.

The starting procedure used by \texttt{gnm} is as follows
\begin{enumerate}
\item
Generate starting values $\theta_i$ for all parameters $i = 1, \ldots, p$ from
the Uniform(-0.1, 0.1) distribution. Shift these values away from zero as follows
\begin{equation*}
\theta_i = \begin{cases}
    \theta_i - 0.1 &  \text{if } \theta < 1 \\
    \theta_i + 0.1 & \text{otherwise}
\end{cases}
\end{equation*}
\item
Replace generic starting values with any starting values specified by plug-in
functions.
\item
Replace default starting values with any starting values specified by the
\texttt{start} argument of \texttt{gnm}.
\item
Compute the \texttt{glm} estimate of any parameters in linear terms that were
not specified by \texttt{start}, offsetting the contribution to the predictor of
any parameters specified by \texttt{start} or a plug-in function.
\item
Run starting iterations: update any parameters in nonlinear terms
that were not specified by \texttt{start} or a plug-in function one at a time,
updating \textit{all} linear terms after each round of nonlinear updates.
\end{enumerate}
Note that no starting iterations will be run if all parameters are specified by
the \texttt{start} argument of \texttt{gnm}.

\subsection{Using \texttt{constrain}}
\label{constrain}

By default, \texttt{gnm} only imposes identifiability constraints on any linear
terms in the model to be fitted. For these terms, the constraints are determined
in the same way as they would be in \texttt{glm}. Any nonlinear terms will be
over-parameterised unless constraints are imposed by the defining plug-in
function (as in the case of \texttt{Dref} for example). For a model with
nonlinear terms that are over-parameterised, \texttt{gnm} will return a random
parameterisation. 

To illustrate this point, consider the following application of \texttt{gnm},
discussed later in Section \ref{RCmodels}
<<"RC homogeneous model 1">>=
data(occupationalStatus)
set.seed(1)
RChomog1 <- gnm(Freq ~ origin + destination + Diag(origin, destination) + 
               Nonlin(MultHomog(origin, destination)), family = poisson, 
               data = occupationalStatus)
@ 
Running the analysis again from a different seed
<<"RC homogeneous model 2">>=
set.seed(2)
RChomog2 <- eval(RChomog1$call)
@ 
gives a different representation of the same model
<<"Compare coefficients">>=
compareCoef <- cbind(coef(RChomog1), coef(RChomog2))
colnames(compareCoef) <- c("RChomog1", "RChomog2") 
compareCoef
@
Even though the linear terms are constrained, the parameter estimates for
these terms still change, because these terms are aliased with the higher order
multiplicative interaction, which is unconstrained.

Additional constraints may be specified through the \texttt{constrain} argument
of \texttt{gnm}. This argument indicates parameters that are to be constrained 
to zero in the fitting process. Parameters can be indicated by a logical vector,
a vector of indices or, if \texttt{constrain = "pick"} they can be selected
through a Tk dialog. 
 
In the case above, constraining one level of the homogeneous multiplicative
factor is sufficient to make the parameters of the nonlinear term
identifiable, and hence all parameters in the model identifiable. For example,
setting the last level of the homogeneous multiplicative factor to zero 
<<"RC homogeneous constrained model">>=
multCoef <- coef(RChomog1)[grep("Mult", names(coef(RChomog1)))]
set.seed(1)
RChomogConstrained1 <- update(RChomog1, constrain = 31, 
                              start = c(rep(NA, 23), multCoef - multCoef[8]))
set.seed(2)
RChomogConstrained2 <- eval(RChomogConstrained1$call)
identical(coef(RChomogConstrained1), coef(RChomogConstrained2))
@
gives the same results regardless of the random seed set beforehand.

It is not usually so straightforward to constrain all the parameters in a
generalized nonlinear model. However,the simple constraints imposed by
\texttt{constrain} are often sufficient to make particular coefficients of
interest identifiable. The functions \texttt{checkEstimable} or
\texttt{getContrasts}, described in Section \ref{Methods} may be used to check
whether particular contrasts are estimable.

\subsection{Using \texttt{eliminate}}
\label{eliminate}

Sometimes a model will include a ``stratification'' factor which identifies units
for which a unit-specific intercept should be estimated. It is often the case
that such factors have a large number of levels and though they are required in
the model, are not of direct interest in themselves. 

The \texttt{eliminate} argument of \texttt{gnm} can be used to specify a
stratification factor in a model, so that the factor can be handled more
efficiently. The factor should be specified as a formula with a single term, for
example
\begin{alltt}
    gnm(mu ~ -1 + unitID + A + B + Mult(A, B), eliminate = ~ unitID)               
\end{alltt}
The use of \texttt{eliminate} makes the specification of a stratification factor
in the model formula redundant, so the above call is equivalent to 
\begin{alltt}
    gnm(mu ~ A + B + Mult(A, B), eliminate = ~ unitID)               
\end{alltt}
or even
\begin{alltt}
    gnm(mu ~ -1 + A + B + Mult(A, B), eliminate = ~ unitID)               
\end{alltt}

Specifying a stratification factor through \texttt{eliminate} has two
advantages. First, the parameters in the factor are estimated more
efficiently. Second, the estimated parameters are excluded from the returned vector of
coefficients, so that summaries of the model focus on the coefficients of interest.

* bit more on estimation here? *

\section{Methods and Accessor functions}
\label{Methods}

\texttt{gnm} returns an object of class \texttt{c("gnm", "glm", "lm")}. There
are several methods that have been written for objects of class \texttt{"glm"}
or \texttt{"lm"} to facilitate evaluation of the fitted model they
describe. Out of the generic functions in the \texttt{base},
\texttt{stats} and \texttt{graphics} packages for which methods have been written
for \texttt{"glm"} or \texttt{"lm"} objects, Figure \ref{glm.lm} shows those
that can be used to analyse \texttt{"gnm"} objects, whilst Figure \ref{!glm.lm} shows
those that are not implemented for \texttt{"gnm"} objects.

\begin{figure}[!tbph]
    \centering
    \begin{fbox} 
        {
          \begin{tabular*}{7.5cm}{@{\extracolsep{\fill}}lll@{\extracolsep{\fill}}}
              case.names	&	hatvalues	&	print	\\
              coef	&	influence	&	residuals	\\
              cooks.distance	&	labels	&	rstandard	\\
              deviance	&	logLik	&	summary	\\
              extractAIC	&	model.frame	&	variable.names	\\
              family	&	model.matrix	&	vcov	\\
              formula	&	plot	&	weights	\\
          \end{tabular*}
        }
    \end{fbox}
    \caption{Generic functions in the \texttt{base}, \texttt{stats} and
      \texttt{graphics} packages that can be used to analyse \texttt{"gnm"} objects.}
    \label{glm.lm}
\end{figure}

\begin{figure}[!tbph]
    \centering
    \begin{fbox} 
        {
          \begin{tabular*}{4.5cm}{@{\extracolsep{\fill}}ll@{\extracolsep{\fill}}}
              add1	&	drop1	\\
              alias	&	dummy.coef	\\
              anova	&	effects	\\
              confint	&	kappa	\\
              dfbeta	&	predict	\\
              dfbetas	&	proj	\\
          \end{tabular*}
        }
    \end{fbox}
    \caption{Generic functions in the \texttt{base}, \texttt{stats} and
      \texttt{graphics} packages for which methods have been written for
      \texttt{"glm"} or \texttt{"lm"} objects, but which are not implemented for
      \texttt{"gnm"} objects.}
    \label{!glm.lm}
\end{figure}

In addition to the accessor functions shown in Figure \ref{glm.lm}, the
\texttt{gnm} package provides a new generic function \texttt{termPredictors}
that has methods for objects of class \texttt{"gnm"}, \texttt{"glm"} and
\texttt{"lm"}. This function returns the additive contribution of each term to the
predictor. 

Most of the methods listed in Figure \ref{glm.lm} can be used as they would be
for \texttt{"glm"} or \texttt{"lm"} objects, however care must be taken with
\texttt{vcov}, as the variance-covariance matrix will depend on the
parameterization of the model. In particular, standard errors calculated using
the variance-covariance matrix will only be valid for parameters or contrasts
that are estimable! 

The \texttt{checkEstimable} function can be used to check the estimability of
contrasts. Consider the following model, that is described later in Section
\ref{Unidiff}
<<"Double UNIDIFF model">>=
data(cautres)
doubleUnidiff <- gnm(Freq ~ election:vote + election:class:religion
                     + Mult(Exp(election - 1), religion:vote - 1) +
                     Mult(Exp(election - 1), class:vote - 1), family = poisson, 
                     data = cautres)
@ 
The effects of the first factor of the first multiplicative term are
estimable when the estimate of one of these effects is constrained to zero, say
the effect of the last level. The parameters to be estimated are then the
differences between each effect and the effect of the last level. These
differences can be represented by a contrast matrix as follows 
<<"Contrast matrix">>=
coefs <- names(coef(doubleUnidiff))
contrCoefs <- coefs[grep("Mult1.Factor1", coefs)]
contrMatrix <- matrix(0, length(coefs), length(contrCoefs), 
                      dimnames = list(coefs, contrCoefs))
contrMatrix[contrCoefs, 1:(ncol(contrMatrix) - 1)] <- contr.sum(contrCoefs)
contrMatrix[contrCoefs, 1:(ncol(contrMatrix) - 1)]
@ 
and then their estimability can be checked using \texttt{checkEstimable}
<<"Check estimability 1">>=
checkEstimable(doubleUnidiff, contrMatrix)
@ 
which confirms that the effects for the other three levels are estimable when 
the effect for the last parameter is set to zero.

However, applying the equivalent constraint to the second factor in the
interaction is not sufficient to make the parameters in that factor estimable:
<<"Check estimability 2">>=
coefs <- names(coef(doubleUnidiff))
contrCoefs <- coefs[grep("Mult1.Factor2", coefs)]
contrMatrix <- matrix(0, length(coefs), length(contrCoefs), 
                      dimnames = list(coefs, contrCoefs))
contrMatrix[contrCoefs, 1:(ncol(contrMatrix) - 1)] <- contr.sum(contrCoefs)
checkEstimable(doubleUnidiff, contrMatrix)
@ 

To investigate simple contrasts such as those above, it
is easiest to use the \texttt{getContrasts} function, which checks the
estimability of the contrasts and returns the parameter estimates with their
standard errors. Returning to the example of the first factor in the first
multiplictaive interaction, the differences between each effect and the effect
of the last level can be obtained as follows 
<<"Get contrasts 1">>=
coefs.of.interest <- grep("Mult1.Factor1", names(coef(doubleUnidiff)))
getContrasts(doubleUnidiff, coefs.of.interest)
@ %def 
Attempting to obtain the equivalent contrasts for the second factor produces the
following result
<<"Get contrasts 2">>=
coefs.of.interest <- grep("Mult1.Factor2", names(coef(doubleUnidiff)))
getContrasts(doubleUnidiff, coefs.of.interest)
@ %def
\section{Examples}
\label{Examples}

This section provides examples of the wide range of models that may be fitted
using the \texttt{gnm} package. Sections \ref{RCmodels}, \ref{Dref} and \ref{Unidiff}
consider various models for contingency tables; Section \ref{GAMMI} considers
GAMMI models which are typically used in agricultural applications, and Section
\ref{Stereotype} considers the sterotype model, which is used to model an
ordinal response.

\subsection{Row-column Association Models}
\label{RCmodels}

There are several models that have been proposed for modelling the relationship
between the cell means of a contingency table and the cross-classifying
factors. The following examples consider the row-column association models
proposed by \citet{Good79}. The examples shown use data from two-way contingency
tables, but the \texttt{gnm} package can also be used to fit the equivalent
models for higher order tables.

\subsubsection{RC(1) model}

rc1model
rc2model
inc Goodman multhomog

\subsection{Diagonal Reference Models}
\label{Dref}
\subsection{Uniform Difference (UNIDIFF) Models}
\label{Unidiff}

inc cautres double unidiff 

\subsection{Generalized Additive and Mulipliactive (GAMMI) Models}
\label{GAMMI}

\subsection{Stereotype Models}
\label{Stereotype}

\appendix

\section{User-level Functions}

\bibliography{gnm}
\bibliographystyle{plain}

\end{document}
